## 10.05 회의록정리

> 프로젝트: SNS 알림 시스템 구축
- 팀명: 힐링 캠프
- 컨셉: 싸이월드 모티브의 SNS, 인스타 스타일 알림 기능
- 기능: 웹 푸시 알림, 네이버 클라우드 파파고 번역을 이용한 채팅, 음성-to-텍스트 변환 API
- 목표: 글로벌 사용자 대상 웹 서버, 장애인 및 외국인에게 접근성 좋은 앱


> 핵심 조언 및 추천
- 요구사항 명세: 고객의 요구는 추상적일 수 있으니 세부 구현사항을 명확히 해야 합니다. 네이버 번역 API의 언어 제한 등 세부 사항을 철저히 확인하세요.
- 중간 보고: 주기적인 중간 보고가 필요합니다. 프로젝트 상태와 진행 사항을 간트 차트나 "지라"를 이용하여 관리하면 좋습니다.
- Git 활용: Git의 기본 원칙과 사용법을 익혀 프로젝트 버전 관리에 활용하세요. 태그 및 브랜치를 적절히 활용하며, 커밋 메시지는 명확하게 작성하세요.
- 아키텍처 및 서버 통신: 로드 밸런서, VPC 내 통신, 클라우드 통신의 복잡성을 고려하면서 구축하세요. 또한, GRPC를 사용하여 서버 간 통신의 효율성을 높이는 것을 권장합니다.
- 프로젝트 관점: 시간상 제한과 프로젝트의 복잡성을 고려하여 주요 기능의 중점을 맞추세요. 너무 많은 기능보다는 완성도와 접근성을 우선시 하세요.

> 10.12 까지 해야할 일
- 요구사항 명세서 작성
수많은 설계 문서 중 하나인 요구사항 명세서를 작성하라고 함
요구사항 명세서를 작성하면 해야 될 일들의 목록이 나옴
명세서에 안 나왔으니까 정확하게 여러분들이 얼마나 해야 되는지 일의 분량 자체가 정해져 있지 않음

- 스케줄의 중요성
프로젝트 매니저나 프로덕트 매니저들이 스케줄을 잡는 것이 필요함
스케줄은 언제까지는 무엇을 끝을 내겠다는 스케줄이 필요함
to-do list 작성 해볼것!

 - 태그의 코멘트
태그를 생성할 때의 코멘트는 상세하게 작성하는 것이 좋다.
너무 간략한 코멘트는 해당 버전의 주요 변경 사항이나 목적을 파악하기 어렵게 만든다.


--------

@pangorithm 질문
레디스와 세션의 관계
서버 여러 개를 분리해서 세션 관리를 쿠키와 레디스로 하려고 하는데 알맞은 방식인지?

서버가 여러 개로 분리되어 있음.
세션 관리에 쿠키와 레디스 사용을 고려중.
레디스는 인메모리 데이터베이스.
세션을 통한 서버 간 통신의 가능성에 대한 의문.

- MSA와 서버 간 통신:
현재 서버 구조가 MSA(Microservice Architecture) 방향으로 가고 있음을 느낌.
각 서버 간의 통신은 GRPC나 REST API를 활용하여 처리 가능.
세션은 주로 브라우저와 서버 간의 통신을 위해 사용되며, 사용자 인증 및 상태 유지 목적.

- 메시지 큐와 서버 간 통신 최적화:
서버 간 통신 최적화를 위해 메시지 큐(MQ) 활용 제안.
서버와 브라우저 간의 통신은 주로 세션과 쿠키 사용, 서버 간의 통신은 더 빠른 메커니즘이 필요.

- GRPC 사용 추천: 
REST API보다 더 효율적인 통신 가능.
REST API는 HTTP 프로토콜 사용시 많은 헤더 정보 포함.
큰 데이터 전송 시 헤더 처리로 인한 지연 문제.

결론:
세션 외의 다른 방법, 특히 GRPC를 활용하여 서버 간 통신의 효율성을 높일 것을 권장.

마지막으로, 현업의 작업 사이클과 텐션을 이해하며 경험하는 것이 중요합니다. 학습과 실제 적용을 병행하며 프로젝트를 진행해보세요.

-------
 요약 정리

# 주제: SNS 알림 시스템 구축 프로젝트
팀명: 힐링 캠프

기본 컨셉:

싸이월드를 모티브로 한 SNS 시스템
인스타 스타일의 댓글, 좋아요 알림 기능
주요 기능 및 목표:

웹 푸시 알림 시스템: 사용자가 댓글이나 좋아요 등의 활동을 할 때 알림 제공
소통 가능한 웹 서버 구축
네이버 클라우드와 연계한 파파고 시스템을 이용한 채팅 기능
음성을 텍스트로 변환하는 API 사용
글로벌 사용자를 위한 웹 서버 구축 목표
추가 목표:

장애인 및 외국인도 사용 가능한 앱 구축


-----

# 요구사항 분석 및 명세
1. 요구사항의 중요성
요구사항은 고객의 기대치와 제품 또는 서비스의 기능 사이의 다리 역할을 한다.
주제나 아이디어만으로는 부족하며, 구체적인 요구사항 명세가 필요하다.
2. SNS 알림 시스템
기본 아이디어: SNS에서의 활동에 대한 알림 서비스
세부 구현사항:
번역 API의 소스와 타겟 설정 기능
사용자 UI 처리 방법
음성 -> 텍스트 변환 기능 (보이스 네비게이션 사용)
3. API와 언어 지원 제한
네이버 번역 API는 제한된 언어만 지원 (약 6개 언어)
사용자가 원하는 변환 시 제약사항을 고려해야 함
4. 시스템 통합 및 배포
도커, 인킨스 등의 도구를 통한 클라우드 배포 고려
요구사항 명세서를 기반으로 스케줄 계획 필요
5. 비명시적 vs 명시적 요구사항
고객은 대체로 명시적인 요구사항만 제시한다 (예: SNS 알림 기능).
개발팀은 이를 분석하여 숨겨진 비명시적 요구사항을 파악해야 한다.

-----

# 중간 보고서 및 시연 영상 제출 가이드라인
1. 제출의 중요성
완벽하지 않더라도 중간 단계에서의 진행 상황을 보여주는 것이 중요하다.
프로그래스 상태와 앞으로의 계획을 반드시 포함한다.
2. 실무와 중간 보고의 관계
실무에서는 주기적인 중간 보고가 필수적이다.
중간 보고에는 명세서나 설계서 등의 중요 문서가 포함되어야 한다.
3. 프로젝트 관리 도구
간트 차트와 같은 스케줄 관리 도구 활용을 추천한다.
"지라"와 같은 이슈 트래킹 시스템을 통해 프로젝트의 상태와 진행 사항을 관리하는 것이 유용하다.
4. 프로젝트 스케줄링
프로젝트의 주요 기능 및 단계별 목표를 세워 스케줄을 잡아야 한다.
애플 아이폰의 출시 예를 들면, 디자인 → 소프트웨어 통합 → 테스트 등의 단계별 목표와 기간이 정해져야 한다.
5. 깃 커밋 관리
깃을 통해 프로젝트 버전 관리를 할 때, 커밋 메시지는 명확하게 작성해야 한다.
기능 추가(Feature), 버그 수정(Fix) 등의 태그를 사용하여 커밋의 목적을 명시적으로 나타내는 것이 좋다.


-----

# Git 사용의 중요성 및 방법
1. 커밋의 중요성
커밋 로그를 통해 개발 과정의 기록을 확인할 수 있다.
커밋 목록을 통해 어떤 작업이 언제 이루어졌는지, 어떤 목적으로 커밋이 이루어졌는지 확인이 가능하다.
2. 브랜치 사용
여러 사람이 함께 작업할 때 브랜치를 나누어 개발하는 것이 유용하다.
작은 규모의 프로젝트에서는 각 개발자별로 브랜치를 나누어 작업 후 메인 브랜치로 머지하는 방식을 사용할 수 있다.
3. 오픈 소스 및 큰 프로젝트에서의 Git 사용
큰 규모의 프로젝트나 오픈 소스 프로젝트에서는 리포지토리의 포크를 통해 개발이 이루어진다.
개발자는 메인 리포지토리를 포크하여 별도의 리포지토리를 생성하고, 이곳에서 작업 후 Pull Request(PR)를 통해 메인 리포지토리로 작업 내용을 제안한다.
4. Git의 확장성
프로젝트의 규모나 참여 인원에 따라 Git 사용 방식이 달라질 수 있다.
Git의 기본 원칙을 알고 있으면 프로젝트의 특성에 맞게 유연하게 사용할 수 있다.

-----

# Git 사용법 및 중요성
1. Git의 기본
Git은 개인적으로 사용할 수 있는 퍼블릭 버전인 GitHub 이외에도 오픈소스로 제공되므로 자체 서버에 설치하여 사용할 수 있다.
2. 리모트 작업
로컬과 별도의 Git 서버를 사용하여 원격에서 작업을 진행하고 동기화할 수 있다.
3. 태그 (Tag)의 중요성
태그는 Git에서 특정 버전에 이름을 붙이는 기능으로, 버전 관리에 핵심적이다.
태그를 통해 이전 버전과의 차이나 업데이트 내역을 확인할 수 있다.
태그 없이 버전 관리를 진행하면 효과적인 관리가 어렵다.
4. 브랜치 (Branch)의 사용
브랜치는 개발 과정에서 다양한 기능이나 버전을 독립적으로 관리하기 위한 기능이다.
SVN, CVS와 같은 이전의 버전 관리 시스템에서도 브랜치 개념이 있었다.
5. Git 학습의 중요성
Git 사용법을 익히는 것은 프로젝트 관리 뿐만 아니라, 나중의 직장 생활에서도 큰 도움이 된다.
특히 면접에서 Git에 대한 질문이 자주 나오므로, 기본적인 사용법은 숙지하는 것이 좋다.
6. 태그의 코멘트
태그를 생성할 때의 코멘트는 상세하게 작성하는 것이 좋다.
너무 간략한 코멘트는 해당 버전의 주요 변경 사항이나 목적을 파악하기 어렵게 만든다.


-----

# 아키텍처 평가:

아키텍처를 그림.
서버 구축 상태 확인 중.
우측: API 동작 아키텍처.
좌측: 클라우드에서의 서버 구축 아키텍처.
로드 밸런서가 2개 들어가면서 일부 어려움 발생.
로드 밸런서에 대한 논의:

퍼블릭 LD와 프라이빗 LD 존재.
로드 밸런서의 사용 목적: 과도한 트래픽 처리.
개발 서버에서의 과부하 테스트의 필요성 인식.
테스트 환경이 실제 환경과 유사해야 함을 강조.
프라이빗과 퍼블릭의 차이점:

주요 차이: IP 노출 여부와 접근 용이성.
로드 밸런서도 이런 차이점을 기반으로 생각하면 됨.
퍼블릭 IP와 프라이빗 IP의 접근성 차이 설명.
중개 서버를 통한 통신 방법 논의.


----

# 레디스와 세션의 관계
서버 여러 개를 분리해서 세션 관리를 쿠키와 레디스로 하려고 하는데 알맞은 방식인지?

서버가 여러 개로 분리되어 있음.
세션 관리에 쿠키와 레디스 사용을 고려중.

레디스는 인메모리 데이터베이스.
세션을 통한 서버 간 통신의 가능성에 대한 의문.

- MSA와 서버 간 통신:
현재 서버 구조가 MSA(Microservice Architecture) 방향으로 가고 있음을 느낌.
각 서버 간의 통신은 GRPC나 REST API를 활용하여 처리 가능.
세션은 주로 브라우저와 서버 간의 통신을 위해 사용되며, 사용자 인증 및 상태 유지 목적.

- 메시지 큐와 서버 간 통신 최적화:
서버 간 통신 최적화를 위해 메시지 큐(MQ) 활용 제안.
서버와 브라우저 간의 통신은 주로 세션과 쿠키 사용, 서버 간의 통신은 더 빠른 메커니즘이 필요.

- GRPC 사용 추천: 
REST API보다 더 효율적인 통신 가능.
REST API는 HTTP 프로토콜 사용시 많은 헤더 정보 포함.
큰 데이터 전송 시 헤더 처리로 인한 지연 문제.

결론:
세션 외의 다른 방법, 특히 GRPC를 활용하여 서버 간 통신의 효율성을 높일 것을 권장.


-----

# 프라이빗 VPC에서의 서버 통신:

프라이빗 VPC에서의 통신이 필요한 경우 public 연결을 통해 특정 서버와만 통신 가능하게 구성 중.
같은 VPC 내에 있는 서버들은 서로 통신이 가능.
필요에 따라 데이터 접근을 위한 특정 서버 구축 가능.
클라우드 통신의 복잡성:

클라우드에서의 서버 통신 컨셉이 복잡, 이해하기 어려울 수 있음.
GRPC vs REST API:

복잡한 CS 구조보다는 GRPC를 사용하는 것을 추천.
그러나 복잡한 구조가 필요하지 않을 경우, 간단히 REST API로 서버 간 호출이 가능.

------

#VPC 내 통신 및 도커 허브:

VPC 내 서버 간의 통신에 대한 질문 제기.
도커 허브는 이미지 저장소로 사용됨.
깃에서 빌드된 결과물이 젠킨스에 의해 도커 허브로 전달되어 처리됨.
배포와 병합:

각 서버에서 빌드된 이미지를 도커 허브에서 받아 병합 계획.
"병합"이 의미하는 것: 각 서버의 애플리케이션 기능들을 모아 하나의 도메인에서 사용하려는 것.
이와 같은 병합과 배포를 위해서는 IAC(Infrastructure As Code)와 배포에 대한 더 깊은 이해가 필요.
배포 도구와 전략 추천:

젠킨스만으로는 해당 요구사항을 충족시키기 어려움.
앤서블이나 쿠버네티스와 같은 도구를 사용해야 함.
현재 시점에서는 전체 서비스를 하나의 이미지로 만들어 배포하는 방식을 추천.
그 이유는 젠킨스의 한계와 시간적 제약 때문.

-----

# 개발 프로세스:

프로젝트의 초기 단계는 요구사항(Requirement) 수집에서 시작.
고객의 요구사항은 추상적일 수 있음. 이를 세부적으로 나누어 구체화.
상세 설계 후에 구현 단계로 진행, 각 기능별 리스트업 및 일정 계획.
현업의 프로젝트 관리:

기능 목록을 바탕으로 작업 진행도 체크.
작업 상황을 매일 미팅을 통해 체크하며, 이는 현업에서의 일반적인 사이클.
아침 저녁으로 진행 상황을 미팅을 통해 확인.
프로젝트의 목적:

학습한 내용을 실제로 적용해보는 것이 중요하나, 현업에서의 작업 텐션과 경험도 중요.
현업의 작업 사이클과 텐션을 이해하고 경험하기 위해 프로젝트를 진행.
최종 프로젝트 조언:

시간상의 제한이 있으므로, 너무 많은 기능을 포함시키려고 하지 말 것.
기능을 축소하거나 중점을 두어 완성도를 높이는 것이 중요.
초기 버전의 서비스도 많은 투입과 시간이 필요하다는 것을 이해할 필요.






